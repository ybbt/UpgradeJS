// 3. [practice] Написать функцию add которая используется так:

// add(3)(4) // 7;


function add(a) {
	return function(b) {
		return a + b ;
	};

};

// 4. [practice] Усовершенствуй функцию-счётчик из статьи http://learn.javascript.ru/closures так чтобы она могла увеличивать счётчик, сбрасывать и выставлять конкретное значение, при этом саму переменную всё еще нельзя было изменить напрямую. Использование должно выглядеть так:

// let counter = makeCounter();
// counter() // 1;
// counter.reset() // 0;
// counter.set(4); // 4;


function makeCounter() {
	let currentCount = 1;

	function set (newCur){
		currentCount = newCur;
	}
	
	function reset (){
		currentCount = 1;
	}
	
	var f = function() {
		return currentCount++;
	};
	
	f.set = set;
	f.reset = reset;
	
	return f;
}


// 3. [practice] Что выведет в консоли и почему? Представь что ты интерпретатор, как ты прочитаешь и выполнишь этот код? =) Только потом проверь результат в консоли. Объясни результат - почему в консоли именно это?

// const arr = [10, 12, 15, 21];
// for (var i = 0; i < arr.length; i++) {
//   setTimeout(function() {
//     console.log('Index: ' + i + ', element: ' + arr[i]);
//   }, 3000);
// }

// В консоль вьіведется 4 раза undefined, потому что за время паузьі в 3 секундьі цикле успеет завершиться и переменной i уже будет присвоено значение 4, а так как изза var все таймерьі используют одну переменную из общей области видимости и все обратятся к несуществующему єлементу массива с индексом 4.

// Переменная, объявленная через let, видна только в рамках блока {...}, в котором объявлена.

// Это, в частности, влияет на объявления внутри if, while или for.

// так вьіведет все єлементьі, так как на каждом цикле создасться своя переменная i, и каждій таймер обратится к своей переменной:

const arr = [10, 12, 15, 21];
for (let i = 0; i < arr.length; i++) {	
	setTimeout(function() {
		console.log('Index: ' + i + ', element: ' + arr[i]);
	}, 3000);
}




